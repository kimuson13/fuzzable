package gofuzzgen

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/gostaticanalysis/codegen"
	"github.com/kimuson13/showfuzz"
	"golang.org/x/tools/go/analysis"
)

type InputData struct {
	PkgName   string
	Fuzzables []showfuzz.Event
}

var (
	flagOutput string
)

func init() {
	Generator.Flags.StringVar(&flagOutput, "o", "", "output file name")
}

var Generator = &codegen.Generator{
	Name: "gofuzzgen",
	Doc:  "gofuzzgen generate a go fuzzing test template",
	Run:  run,
	Requires: []*analysis.Analyzer{
		showfuzz.Analyzer,
	},
}

func run(pass *codegen.Pass) error {
	if strings.Contains(pass.Pkg.Name(), "_test") {
		return nil
	}
	sfResults := pass.ResultOf[showfuzz.Analyzer].(*showfuzz.Results).Events
	data := InputData{pass.Pkg.Name(), sfResults}
	// fmt.Println(data)

	t, err := template.New("fuzz").Parse(tmpl)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return err
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	if flagOutput == "" {
		pass.Print(string(src))
		return nil
	}

	f, err := os.Create(flagOutput)
	if err != nil {
		return err
	}

	if _, err := fmt.Fprint(f, string(src)); err != nil {
		log.Printf("unexpected err: %v\n", err)
	}

	if err := f.Close(); err != nil {
		return err
	}

	return nil
}

var tmpl = `
// This file is generated by gofuzzgen. 
// Only generate fuzzing template.
package {{ .PkgName }}_test
`
